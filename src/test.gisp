
;;Test primitive
;(write (+ 5 (* 2 6)))

;;Test def
;(def a (+ 1 3))
;(write "30=" (* 5 (+ 2 a)))
;
;;Test defn
;(defn culo (a) (write a) (write 33333333)(write 2222))
;(culo 33)
;
;;Test hashmap
;(defn point (x y) (hashmap :x x :y y))
;(write "Hashmap:" (point 100 200))
;
;;Test vector
;(defn array (x y z) (vector x y z))
;(write "Vector:" (array 100 200 30))
;
;;Test seed
;(seed)
;
;;Test doseq
;(doseq (i (range 2)) (write i) (write i))
;
;;Test profile
;(profile "coso" (list 64))
;
;;Test let
;(let (a 5
;      b (+ 37 5))
;	(write a)
;	(write b)
;	(write (+ a b)))
;
;;Test map
;(map (lambda (i) (+ i 1)) (range 3))
;(map write (range 3))
;(defn testmap (i) (+ i 1))
;(map testmap (range 3))
;
;;Test mapv
;(mapv (lambda (i) (+ i 1)) (range 3))
;(mapv write (range 3))
;(defn testmap (i) (+ i 1))
;(mapv testmap (range 3))
;
;;Test map with vectors
;(map (lambda (i) (+ i 1)) [1 2 3 4 5])
;(mapv (lambda (i) (+ i 1)) [1 2 3 4 5])
;
;;Test exit macro
;(write "Exiting") (exit)
;
;;Test keyword member access
;(def p (hashmap :x 100 :y 200))
;(:x p) (:r p)
;
;;Test if
;(if (= 1 2) (write "equals") (write "not equals"))
;(if (= 2 2) (write "equals") (write "not equals"))
;
;;Test apply
;(write (apply str (list "a" "b" "c" "d" "e")))
;
;;Test progn
;(progn (write "a") (write "b") (write "c") (+ 1 2))
;
;;Test reduce
;(reduce (lambda (curr next) (+ curr next)) 0 (range 5))
;(defn testreduce (curr next) (+ curr next))
;(reduce testreduce 0 (range 5))
;(reduce + 0 (range 5))
;
;
;
;;Test Lambda
;((lambda (i) (+ i 1)) 3)


;;Test cond
;(def testcond 4)
;(cond 
;	(= testcond 1)
;		(write "uno!")
;	(= testcond 2)
;		(write "due!")
;	(= testcond 3)
;		(write "tre!")
;	:else
;		(write "else!"))



;;Test filter
;(write "filter")
;(write (filter #(= 3 %) [3 4 nil 5 nil 6]))
;(write (filter #(not-nil? %) (list 3 4 nil 5 6)))

;;Test sort
;(write "sort")
;(write (sort (lambda (a b) (< a b)) [1 5 3 6 7 3 5 6 7]))


(defn test (l)
	(write l)
	(if (nil? l)
		nil
		(test (cdr l))))

(write (str "test:" (test (list 1 2 3))))




(defn flatten (l)
    (write (str "cose: " l))
    (cond 
        (nil? l)
            nil
        (pair? (car l))
            (concat (flatten (car l)) (flatten (cdr l)))
        :else
            (cons (car l) (flatten (cdr l)))))
    
    
(write (str "flatten: " (flatten (list 1 2 (list 3 4)))))





(write (str "abs: " -0.5))
(write (str "abs: " (abs -0.5)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;TEST CORE FUNCTIONS


;(concat [1 2 3] [4 5 6])
;(write "coso")
;(str "ciao")

;(str "test:" (map (lambda (i) (* 2 i)) [1 2 3 4]))


;(write (take 6 2 [1 2 3 4 5]))
;(write (take 6 2 (list 1 2 3 4 5)))

;(write (drop 2 [1 2 3 4 5]))
;(write (drop 2 (list 1 2 3 4 5)))


;(write (empty? [1 2 3 4]))
;(write (empty? []))
;(write (empty? (list 1 2 3 4)))
;(write (empty? (list )))
;(write (empty? {:a 1}))
;(write (empty? {}))
;(write (empty? "ciao"))
;(write (empty? ""))


;(write (append [1 2 3] 4))
;(write (append (list 1 2 3) 4))
;(write (insert [1 2 3] 4))
;(write (insert (list 1 2 3) 4))
;
;(defn partition (n step coll)
;    (if (< (count coll) n)
;        nil
;        (insert (partition n step (drop step coll)) (take n 0 coll) )))
;    
;(write (partition 2 1 [1 2 3 4 5 6 7 8]))
;(write (partition 2 1 (list 1 2 3 4 5 6 7 8)))


;(write (sign -2984732))

